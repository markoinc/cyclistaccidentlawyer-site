#!/usr/bin/env python3
"""
Daily Email Summary for Marko
Compiles intelligence findings and sends at 3pm daily
"""

import sys
import sqlite3
import json
from datetime import datetime, timedelta
from pathlib import Path
import subprocess
import requests

def get_latest_intelligence():
    """Get latest findings from vendor database"""
    try:
        db_path = "/home/ec2-user/clawd/projects/pi-vendors/data/vendor_intel.db"
        if not Path(db_path).exists():
            return "No intelligence database found"
        
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        # Get items from last 24 hours
        yesterday = (datetime.now() - timedelta(days=1)).isoformat()
        
        cursor.execute("""
            SELECT source, title, content, url, scraped_at 
            FROM raw_data 
            WHERE scraped_at > ? AND processed = 1
            ORDER BY scraped_at DESC 
            LIMIT 10
        """, (yesterday,))
        
        results = cursor.fetchall()
        conn.close()
        
        if not results:
            return "No new intelligence in last 24 hours"
        
        intel_text = ""
        for source, title, content, url, scraped_at in results:
            intel_text += f"**{source.upper()}:** {title}\n"
            intel_text += f"Time: {scraped_at}\n"
            if url:
                intel_text += f"Link: {url}\n"
            intel_text += f"Summary: {content[:200]}...\n\n"
        
        return intel_text
        
    except Exception as e:
        return f"Error fetching intelligence: {str(e)}"

def get_recent_findings():
    """Get recent findings from memory files"""
    try:
        memory_path = Path("/home/ec2-user/agents/scout/memory")
        findings = []
        
        # Check last 3 days of memory files
        for i in range(3):
            date = (datetime.now() - timedelta(days=i)).strftime("%Y-%m-%d")
            file_path = memory_path / f"{date}.md"
            if file_path.exists():
                content = file_path.read_text()
                if "FINDING:" in content or "INTEL:" in content:
                    findings.append(f"**{date}:**\n{content[:300]}...\n")
        
        return "\n".join(findings) if findings else "No recent findings in memory"
    except Exception as e:
        return f"Error reading memory: {str(e)}"

def get_pipeline_status():
    """Check pipeline status from mission doc"""
    try:
        mission_path = "/home/ec2-user/clawd/data/agent-mission-v2.md"
        with open(mission_path, 'r') as f:
            content = f.read()
        
        # Extract pipeline section
        if "Hot Pipeline" in content:
            start = content.find("Hot Pipeline")
            end = content.find("**Tools Ready:**")
            if end == -1:
                end = start + 1000
            pipeline_section = content[start:end]
            return pipeline_section[:500] + "..."
        
        return "Pipeline status not found"
    except Exception as e:
        return f"Error reading pipeline: {str(e)}"

def send_email_summary():
    """Compile and send daily summary"""
    today = datetime.now().strftime("%Y-%m-%d")
    
    # Compile summary
    summary = f"""
üîç DAILY INTELLIGENCE SUMMARY - {today}

## Latest Intelligence
{get_latest_intelligence()}

## Pipeline Status  
{get_pipeline_status()}

## Recent Findings
{get_recent_findings()}

## Scrapers Status
- Reddit: Monitoring PI attorney discussions
- X/Twitter: Tracking AI agent trends
- Reviews: Watching competitor complaints
- LinkedIn: Company intelligence

## Action Items
- High-value prospects ready for Hunter outreach
- Competitor weaknesses to exploit
- Market trends to capitalize on

---
Generated by SCOUT at {datetime.now().strftime("%H:%M UTC")}
"""

    # For now, save to file and use message tool
    summary_path = f"/tmp/daily_summary_{today}.md"
    with open(summary_path, 'w') as f:
        f.write(summary)
    
    print(f"Summary saved to {summary_path}")
    print("Summary content:")
    print(summary)
    
    return summary

if __name__ == "__main__":
    send_email_summary()